import { AsyncCallerParams } from "./utils/async_caller.js";
import { Dataset, Example, ExampleUpdate, Feedback, KVMap, Run, RunCreate, RunUpdate, ScoreType, TracerSession, TracerSessionResult, ValueType, DataType } from "./schemas.js";
import { RunEvaluator } from "./evaluation/evaluator.js";
interface ClientConfig {
    apiUrl?: string;
    apiKey?: string;
    callerOptions?: AsyncCallerParams;
    timeout_ms?: number;
}
interface ListRunsParams {
    projectId?: string;
    projectName?: string;
    executionOrder?: number;
    parentRunId?: string;
    referenceExampleId?: string;
    datasetId?: string;
    startTime?: Date;
    endTime?: Date;
    runType?: string;
    error?: boolean;
    id?: string[];
    limit?: number;
    offset?: number;
    query?: string;
    filter?: string;
    orderBy?: string[];
}
interface UploadCSVParams {
    csvFile: Blob;
    fileName: string;
    inputKeys: string[];
    outputKeys: string[];
    description?: string;
    dataType?: DataType;
    name?: string;
}
interface CreateRunParams {
    name: string;
    inputs: KVMap;
    run_type: string;
    execution_order?: number;
    id?: string;
    start_time?: number;
    end_time?: number;
    extra?: KVMap;
    error?: string;
    serialized?: object;
    outputs?: KVMap;
    reference_example_id?: string;
    child_runs?: RunCreate[];
    parent_run_id?: string;
    project_name?: string;
}
export declare class Client {
    private apiKey?;
    private apiUrl;
    private caller;
    private timeout_ms;
    constructor(config?: ClientConfig);
    static getDefaultClientConfig(): {
        apiUrl: string;
        apiKey?: string;
    };
    private validateApiKeyIfHosted;
    private getHostUrl;
    private get headers();
    private _get;
    private _getPaginated;
    createRun(run: CreateRunParams): Promise<void>;
    updateRun(runId: string, run: RunUpdate): Promise<void>;
    readRun(runId: string, { loadChildRuns }?: {
        loadChildRuns: boolean;
    }): Promise<Run>;
    getRunUrl({ runId, }: {
        runId: string;
    }): Promise<string | undefined>;
    private _loadChildRuns;
    listRuns({ projectId, projectName, parentRunId, referenceExampleId, datasetId, startTime, endTime, executionOrder, runType, error, id, limit, offset, query, filter, orderBy, }: ListRunsParams): AsyncIterable<Run>;
    deleteRun(runId: string): Promise<void>;
    shareRun(runId: string, { shareId }?: {
        shareId?: string;
    }): Promise<string>;
    unshareRun(runId: string): Promise<void>;
    readRunSharedLink(runId: string): Promise<string | undefined>;
    createProject({ projectName, projectExtra, upsert, }: {
        projectName: string;
        projectExtra?: object;
        upsert?: boolean;
    }): Promise<TracerSession>;
    readProject({ projectId, projectName, }: {
        projectId?: string;
        projectName?: string;
    }): Promise<TracerSessionResult>;
    listProjects(): AsyncIterable<TracerSession>;
    deleteProject({ projectId, projectName, }: {
        projectId?: string;
        projectName?: string;
    }): Promise<void>;
    uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }: UploadCSVParams): Promise<Dataset>;
    createDataset(name: string, { description, dataType, }?: {
        description?: string;
        dataType?: DataType;
    }): Promise<Dataset>;
    readDataset({ datasetId, datasetName, }: {
        datasetId?: string;
        datasetName?: string;
    }): Promise<Dataset>;
    listDatasets({ limit, offset, datasetIds, datasetName, datasetNameContains, }?: {
        limit?: number;
        offset?: number;
        datasetIds?: string[];
        datasetName?: string;
        datasetNameContains?: string;
    }): AsyncIterable<Dataset>;
    deleteDataset({ datasetId, datasetName, }: {
        datasetId?: string;
        datasetName?: string;
    }): Promise<void>;
    createExample(inputs: KVMap, outputs: KVMap, { datasetId, datasetName, createdAt, }: {
        datasetId?: string;
        datasetName?: string;
        createdAt?: Date;
    }): Promise<Example>;
    readExample(exampleId: string): Promise<Example>;
    listExamples({ datasetId, datasetName, exampleIds, }?: {
        datasetId?: string;
        datasetName?: string;
        exampleIds?: string[];
    }): AsyncIterable<Example>;
    deleteExample(exampleId: string): Promise<void>;
    updateExample(exampleId: string, update: ExampleUpdate): Promise<object>;
    evaluateRun(run: Run | string, evaluator: RunEvaluator, { sourceInfo, loadChildRuns, }?: {
        sourceInfo?: KVMap;
        loadChildRuns: boolean;
    }): Promise<Feedback>;
    createFeedback(runId: string, key: string, { score, value, correction, comment, sourceInfo, feedbackSourceType, }: {
        score?: ScoreType;
        value?: ValueType;
        correction?: object;
        comment?: string;
        sourceInfo?: object;
        feedbackSourceType?: "API" | "MODEL";
    }): Promise<Feedback>;
    updateFeedback(feedbackId: string, { score, value, correction, comment, }: {
        score?: number | boolean | null;
        value?: number | boolean | string | object | null;
        correction?: object | null;
        comment?: string | null;
    }): Promise<Feedback>;
    readFeedback(feedbackId: string): Promise<Feedback>;
    deleteFeedback(feedbackId: string): Promise<void>;
    listFeedback({ runIds, }?: {
        runIds?: string[];
    }): AsyncIterable<Feedback>;
}
export {};
