import { BaseCallbackConfig, Callbacks } from "../callbacks/manager.js";
import { BasePromptValue, Generation, ChatGeneration, BaseMessage } from "./index.js";
import { Runnable, RunnableConfig } from "./runnable.js";
/**
 * Options for formatting instructions.
 */
export interface FormatInstructionsOptions {
}
export declare abstract class BaseLLMOutputParser<T = unknown> extends Runnable<string | BaseMessage, T> {
    abstract parseResult(generations: Generation[] | ChatGeneration[], callbacks?: Callbacks): Promise<T>;
    parseResultWithPrompt(generations: Generation[] | ChatGeneration[], _prompt: BasePromptValue, callbacks?: Callbacks): Promise<T>;
    invoke(input: string | BaseMessage, options?: RunnableConfig): Promise<T>;
}
/**
 * Class to parse the output of an LLM call.
 */
export declare abstract class BaseOutputParser<T = unknown> extends BaseLLMOutputParser<T> {
    parseResult(generations: Generation[] | ChatGeneration[], callbacks?: Callbacks): Promise<T>;
    /**
     * Parse the output of an LLM call.
     *
     * @param text - LLM output to parse.
     * @returns Parsed output.
     */
    abstract parse(text: string, callbacks?: Callbacks): Promise<T>;
    parseWithPrompt(text: string, _prompt: BasePromptValue, callbacks?: Callbacks): Promise<T>;
    /**
     * Return a string describing the format of the output.
     * @returns Format instructions.
     * @param options - Options for formatting instructions.
     * @example
     * ```json
     * {
     *  "foo": "bar"
     * }
     * ```
     */
    abstract getFormatInstructions(options?: FormatInstructionsOptions): string;
    /**
     * Return the string type key uniquely identifying this class of parser
     */
    _type(): string;
}
/**
 * Class to parse the output of an LLM call that also allows streaming inputs.
 */
export declare abstract class BaseTransformOutputParser<T = unknown> extends BaseOutputParser<T> {
    _transform(inputGenerator: AsyncGenerator<string | BaseMessage>): AsyncGenerator<T>;
    transform(inputGenerator: AsyncGenerator<string | BaseMessage>, options: BaseCallbackConfig): AsyncGenerator<T>;
}
/**
 * OutputParser that parses LLMResult into the top likely string.
 */
export declare class StringOutputParser extends BaseTransformOutputParser<string> {
    static lc_name(): string;
    lc_namespace: string[];
    lc_serializable: boolean;
    parse(text: string): Promise<string>;
    getFormatInstructions(): string;
}
/**
 * OutputParser that parses LLMResult into the top likely string and
 * encodes it into bytes.
 */
export declare class BytesOutputParser extends BaseTransformOutputParser<Uint8Array> {
    static lc_name(): string;
    lc_namespace: string[];
    lc_serializable: boolean;
    protected textEncoder: TextEncoder;
    parse(text: string): Promise<Uint8Array>;
    getFormatInstructions(): string;
}
export declare class OutputParserException extends Error {
    output?: string;
    constructor(message: string, output?: string);
}
