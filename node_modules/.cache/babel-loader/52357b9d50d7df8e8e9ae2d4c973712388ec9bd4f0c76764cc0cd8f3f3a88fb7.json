{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseUnionDef = exports.primitiveMappings = void 0;\nconst parseDef_1 = require(\"../parseDef\");\nexports.primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef(def, refs) {\n  if (refs.target === \"openApi3\") return asAnyOf(def, refs);\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n  if (options.every(x => x._def.typeName in exports.primitiveMappings && (!x._def.checks || !x._def.checks.length))) {\n    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n    const types = options.reduce((types, x) => {\n      const type = exports.primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n      return type && !types.includes(type) ? [...types, type] : types;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every(x => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    // all options literals\n    const types = options.reduce((acc, x) => {\n      const type = typeof x._def.value;\n      switch (type) {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          return [...acc, type];\n        case \"bigint\":\n          return [...acc, \"integer\"];\n        case \"object\":\n          if (x._def.value === null) return [...acc, \"null\"];\n        case \"symbol\":\n        case \"undefined\":\n        case \"function\":\n        default:\n          return acc;\n      }\n    }, []);\n    if (types.length === options.length) {\n      // all the literals are primitive, as far as null can be considered primitive\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x) => {\n          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n        }, [])\n      };\n    }\n  } else if (options.every(x => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter(x => !acc.includes(x))], [])\n    };\n  }\n  return asAnyOf(def, refs);\n}\nexports.parseUnionDef = parseUnionDef;\nconst asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => (0, parseDef_1.parseDef)(x._def, Object.assign(Object.assign({}, refs), {\n    currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n  }))).filter(x => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0));\n  return anyOf.length ? {\n    anyOf\n  } : undefined;\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","parseUnionDef","primitiveMappings","parseDef_1","require","ZodString","ZodNumber","ZodBigInt","ZodBoolean","ZodNull","def","refs","target","asAnyOf","options","Map","Array","from","values","every","x","_def","typeName","checks","length","types","reduce","type","includes","description","acc","uniqueTypes","filter","i","a","indexOf","enum","anyOf","map","parseDef","assign","currentPath","strictUnions","keys","undefined"],"sources":["/Users/idasilfverskiold/gptSandbox/reactlangchain/sandbox/node_modules/zod-to-json-schema/src/parsers/union.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseUnionDef = exports.primitiveMappings = void 0;\nconst parseDef_1 = require(\"../parseDef\");\nexports.primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nfunction parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in exports.primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = exports.primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nexports.parseUnionDef = parseUnionDef;\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => (0, parseDef_1.parseDef)(x._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, \"anyOf\", `${i}`] })))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}