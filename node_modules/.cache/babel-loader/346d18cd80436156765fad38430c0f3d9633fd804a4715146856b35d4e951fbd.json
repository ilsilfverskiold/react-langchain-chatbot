{"ast":null,"code":"export const parseFString = template => {\n  // Core logic replicated from internals of pythons built in Formatter class.\n  // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n  const chars = template.split(\"\");\n  const nodes = [];\n  const nextBracket = (bracket, start) => {\n    for (let i = start; i < chars.length; i += 1) {\n      if (bracket.includes(chars[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  let i = 0;\n  while (i < chars.length) {\n    if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n      nodes.push({\n        type: \"literal\",\n        text: \"{\"\n      });\n      i += 2;\n    } else if (chars[i] === \"}\" && i + 1 < chars.length && chars[i + 1] === \"}\") {\n      nodes.push({\n        type: \"literal\",\n        text: \"}\"\n      });\n      i += 2;\n    } else if (chars[i] === \"{\") {\n      const j = nextBracket(\"}\", i);\n      if (j < 0) {\n        throw new Error(\"Unclosed '{' in template.\");\n      }\n      nodes.push({\n        type: \"variable\",\n        name: chars.slice(i + 1, j).join(\"\")\n      });\n      i = j + 1;\n    } else if (chars[i] === \"}\") {\n      throw new Error(\"Single '}' in template.\");\n    } else {\n      const next = nextBracket(\"{}\", i);\n      const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n      nodes.push({\n        type: \"literal\",\n        text\n      });\n      i = next < 0 ? chars.length : next;\n    }\n  }\n  return nodes;\n};\nexport const interpolateFString = (template, values) => parseFString(template).reduce((res, node) => {\n  if (node.type === \"variable\") {\n    if (node.name in values) {\n      return res + values[node.name];\n    }\n    throw new Error(`Missing value for input ${node.name}`);\n  }\n  return res + node.text;\n}, \"\");\nexport const DEFAULT_FORMATTER_MAPPING = {\n  \"f-string\": interpolateFString,\n  jinja2: (_, __) => \"\"\n};\nexport const DEFAULT_PARSER_MAPPING = {\n  \"f-string\": parseFString,\n  jinja2: _ => []\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n    throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n  }\n  try {\n    const dummyInputs = inputVariables.reduce((acc, v) => {\n      acc[v] = \"foo\";\n      return acc;\n    }, {});\n    renderTemplate(template, templateFormat, dummyInputs);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e) {\n    throw new Error(`Invalid prompt schema: ${e.message}`);\n  }\n};","map":{"version":3,"names":["parseFString","template","chars","split","nodes","nextBracket","bracket","start","i","length","includes","push","type","text","j","Error","name","slice","join","next","interpolateFString","values","reduce","res","node","DEFAULT_FORMATTER_MAPPING","jinja2","_","__","DEFAULT_PARSER_MAPPING","renderTemplate","templateFormat","inputValues","parseTemplate","checkValidTemplate","inputVariables","validFormats","Object","keys","dummyInputs","acc","v","e","message"],"sources":["/Users/idasilfverskiold/gptSandbox/reactlangchain/sandbox/node_modules/langchain/dist/prompts/template.js"],"sourcesContent":["export const parseFString = (template) => {\n    // Core logic replicated from internals of pythons built in Formatter class.\n    // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n    const chars = template.split(\"\");\n    const nodes = [];\n    const nextBracket = (bracket, start) => {\n        for (let i = start; i < chars.length; i += 1) {\n            if (bracket.includes(chars[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    let i = 0;\n    while (i < chars.length) {\n        if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n            nodes.push({ type: \"literal\", text: \"{\" });\n            i += 2;\n        }\n        else if (chars[i] === \"}\" &&\n            i + 1 < chars.length &&\n            chars[i + 1] === \"}\") {\n            nodes.push({ type: \"literal\", text: \"}\" });\n            i += 2;\n        }\n        else if (chars[i] === \"{\") {\n            const j = nextBracket(\"}\", i);\n            if (j < 0) {\n                throw new Error(\"Unclosed '{' in template.\");\n            }\n            nodes.push({\n                type: \"variable\",\n                name: chars.slice(i + 1, j).join(\"\"),\n            });\n            i = j + 1;\n        }\n        else if (chars[i] === \"}\") {\n            throw new Error(\"Single '}' in template.\");\n        }\n        else {\n            const next = nextBracket(\"{}\", i);\n            const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n            nodes.push({ type: \"literal\", text });\n            i = next < 0 ? chars.length : next;\n        }\n    }\n    return nodes;\n};\nexport const interpolateFString = (template, values) => parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n        if (node.name in values) {\n            return res + values[node.name];\n        }\n        throw new Error(`Missing value for input ${node.name}`);\n    }\n    return res + node.text;\n}, \"\");\nexport const DEFAULT_FORMATTER_MAPPING = {\n    \"f-string\": interpolateFString,\n    jinja2: (_, __) => \"\",\n};\nexport const DEFAULT_PARSER_MAPPING = {\n    \"f-string\": parseFString,\n    jinja2: (_) => [],\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n    if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n        throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n    }\n    try {\n        const dummyInputs = inputVariables.reduce((acc, v) => {\n            acc[v] = \"foo\";\n            return acc;\n        }, {});\n        renderTemplate(template, templateFormat, dummyInputs);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        throw new Error(`Invalid prompt schema: ${e.message}`);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}