{"ast":null,"code":"import { CallbackManager } from \"../callbacks/manager.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream } from \"../util/stream.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks: fields.fallbacks\n    });\n  }\n  _getOptionsList(options, length = 0) {\n    if (Array.isArray(options)) {\n      if (options.length !== length) {\n        throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n      }\n      return options;\n    }\n    return Array.from({\n      length\n    }, () => options);\n  }\n  /**\n   * Default implementation of batch, which calls invoke N times.\n   * Subclasses should override this method if they can batch more efficiently.\n   * @param inputs Array of inputs to each batch call.\n   * @param options Either a single call options object to apply to each batch call or an array for each call.\n   * @param batchOptions.maxConcurrency Maximum number of calls to run at once.\n   * @returns An array of RunOutputs\n   */\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0 ? batchOptions?.maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < inputs.length; i += batchSize) {\n      const batchPromises = inputs.slice(i, i + batchSize).map((input, j) => this.invoke(input, configList[j]));\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    return IterableReadableStream.fromAsyncGenerator(this._streamIterator(input, options));\n  }\n  _separateRunnableConfigFromCallOptions(options = {}) {\n    const runnableConfig = {\n      callbacks: options.callbacks,\n      tags: options.tags,\n      metadata: options.metadata\n    };\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, options?.runType);\n    let output;\n    try {\n      output = await func.bind(this)(input);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n  async *_streamWithConfig(generator, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    // TODO: Find a way to pass the entire streamed value into the callback.\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(\"<streamed value>\", \"input\"), undefined, options?.runType);\n    let output;\n    let concatSupported = true;\n    try {\n      for await (const chunk of generator) {\n        yield chunk;\n        if (concatSupported) {\n          if (output === undefined) {\n            output = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              output = output.concat(chunk);\n            } catch (e) {\n              output = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n  }\n  _patchConfig(config = {}, callbackManager = undefined) {\n    return {\n      ...config,\n      callbacks: callbackManager\n    };\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return thing.lc_runnable;\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      for (const step of [this.first, ...this.middle]) {\n        nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      finalOutput = await this.last.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    let finalOutputs;\n    try {\n      for (let i = 0; i < [this.first, ...this.middle].length; i += 1) {\n        const step = this.steps[i];\n        nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n      }\n      finalOutputs = await this.last.batch(nextStepInputs, runManagers.map(runManager => this._patchConfig(configList[this.steps.length - 1], runManager?.getChild())), batchOptions);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(finalOutputs[i], \"output\"))));\n    return finalOutputs;\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n    let nextStepInput = input;\n    const steps = [this.first, ...this.middle, this.last];\n    // Find the index of the last runnable in the sequence that doesn't have a .transform() method\n    // and start streaming from there\n    const streamingStartStepIndex = steps.length - [...steps].reverse().findIndex(step => typeof step.transform !== \"function\") - 1;\n    try {\n      for (const step of steps.slice(0, streamingStartStepIndex)) {\n        nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    let concatSupported = true;\n    let finalOutput;\n    try {\n      let finalGenerator = await steps[streamingStartStepIndex]._streamIterator(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n      for (const step of steps.slice(streamingStartStepIndex + 1)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        finalGenerator = await step.transform(finalGenerator, this._patchConfig(options, runManager?.getChild()));\n      }\n      for await (const chunk of finalGenerator) {\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = finalOutput.concat(chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable)\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  static from([first, ...runnables]) {\n    return new RunnableSequence({\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1])\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  async invoke(input, options\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n      input\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      for (const [key, runnable] of Object.entries(this.steps)) {\n        const result = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n        output[key] = result;\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output;\n  }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.func = fields.func;\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(async input => this.func(input), input, options);\n  }\n}\n/**\n * A runnable that passes through the input.\n */\nexport class RunnablePassthrough extends Runnable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(input => Promise.resolve(input), input, options);\n  }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n  }\n  bind(kwargs) {\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      }\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, {\n      ...options,\n      ...this.kwargs\n    });\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? options.map(individualOption => ({\n      ...individualOption,\n      ...this.kwargs\n    })) : {\n      ...options,\n      ...this.kwargs\n    };\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, {\n      ...options,\n      ...this.kwargs\n    });\n  }\n}\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnables = fields.runnables;\n  }\n  async invoke(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, options);\n  }\n  async batch(inputs, options, batchOptions) {\n    const keys = inputs.map(input => input.key);\n    const actualInputs = inputs.map(input => input.input);\n    const missingKey = keys.find(key => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map(key => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0 ? batchOptions?.maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs.slice(i, i + batchSize).map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n  async stream(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const output = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (firstError === undefined) {\n      throw new Error(\"No error stored at end of fallback.\");\n    }\n    await runManager?.handleChainError(firstError);\n    throw firstError;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainError(firstError)));\n    throw firstError;\n  }\n}\nfunction _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n  }\n}","map":{"version":3,"names":["CallbackManager","Serializable","IterableReadableStream","_coerceToDict","value","defaultKey","Array","isArray","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","bind","kwargs","RunnableBinding","bound","withFallbacks","fields","RunnableWithFallbacks","runnable","fallbacks","_getOptionsList","options","length","Error","from","batch","inputs","batchOptions","configList","batchSize","maxConcurrency","batchResults","i","batchPromises","slice","map","input","j","invoke","batchResult","Promise","all","push","flat","_streamIterator","stream","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","callbacks","tags","metadata","callOptions","_callWithConfig","func","callbackManager_","configure","undefined","runManager","handleChainStart","toJSON","runType","output","e","handleChainError","handleChainEnd","_streamWithConfig","generator","concatSupported","chunk","concat","_patchConfig","config","callbackManager","pipe","coerceable","RunnableSequence","first","last","_coerceToRunnable","isRunnable","thing","lc_runnable","lc_name","middle","steps","nextStepInput","finalOutput","step","getChild","callbackManagers","runManagers","nextStepInputs","finalOutputs","streamingStartStepIndex","reverse","findIndex","transform","finalGenerator","isRunnableSequence","runnables","RunnableMap","key","entries","result","RunnableLambda","RunnablePassthrough","resolve","mergedOptions","individualOption","RouterRunnable","actualInput","keys","actualInputs","missingKey","find","optionsList","fallback","firstError","outputs"],"sources":["/Users/idasilfverskiold/gptSandbox/reactlangchain/sandbox/node_modules/langchain/dist/schema/runnable.js"],"sourcesContent":["import { CallbackManager } from \"../callbacks/manager.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream } from \"../util/stream.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks: fields.fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options)) {\n            if (options.length !== length) {\n                throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n            }\n            return options;\n        }\n        return Array.from({ length }, () => options);\n    }\n    /**\n     * Default implementation of batch, which calls invoke N times.\n     * Subclasses should override this method if they can batch more efficiently.\n     * @param inputs Array of inputs to each batch call.\n     * @param options Either a single call options object to apply to each batch call or an array for each call.\n     * @param batchOptions.maxConcurrency Maximum number of calls to run at once.\n     * @returns An array of RunOutputs\n     */\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0\n            ? batchOptions?.maxConcurrency\n            : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < inputs.length; i += batchSize) {\n            const batchPromises = inputs\n                .slice(i, i + batchSize)\n                .map((input, j) => this.invoke(input, configList[j]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        return IterableReadableStream.fromAsyncGenerator(this._streamIterator(input, options));\n    }\n    _separateRunnableConfigFromCallOptions(options = {}) {\n        const runnableConfig = {\n            callbacks: options.callbacks,\n            tags: options.tags,\n            metadata: options.metadata,\n        };\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, options?.runType);\n        let output;\n        try {\n            output = await func.bind(this)(input);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    async *_streamWithConfig(generator, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        // TODO: Find a way to pass the entire streamed value into the callback.\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(\"<streamed value>\", \"input\"), undefined, options?.runType);\n        let output;\n        let concatSupported = true;\n        try {\n            for await (const chunk of generator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (output === undefined) {\n                        output = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            output = output.concat(chunk);\n                        }\n                        catch (e) {\n                            output = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    _patchConfig(config = {}, callbackManager = undefined) {\n        return { ...config, callbacks: callbackManager };\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return thing.lc_runnable;\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            for (const step of [this.first, ...this.middle]) {\n                nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            finalOutput = await this.last.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        let finalOutputs;\n        try {\n            for (let i = 0; i < [this.first, ...this.middle].length; i += 1) {\n                const step = this.steps[i];\n                nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n            }\n            finalOutputs = await this.last.batch(nextStepInputs, runManagers.map((runManager) => this._patchConfig(configList[this.steps.length - 1], runManager?.getChild())), batchOptions);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(finalOutputs[i], \"output\"))));\n        return finalOutputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let nextStepInput = input;\n        const steps = [this.first, ...this.middle, this.last];\n        // Find the index of the last runnable in the sequence that doesn't have a .transform() method\n        // and start streaming from there\n        const streamingStartStepIndex = steps.length -\n            [...steps]\n                .reverse()\n                .findIndex((step) => typeof step.transform !== \"function\") -\n            1;\n        try {\n            for (const step of steps.slice(0, streamingStartStepIndex)) {\n                nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        let concatSupported = true;\n        let finalOutput;\n        try {\n            let finalGenerator = await steps[streamingStartStepIndex]._streamIterator(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            for (const step of steps.slice(streamingStartStepIndex + 1)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                finalGenerator = await step.transform(finalGenerator, this._patchConfig(options, runManager?.getChild()));\n            }\n            for await (const chunk of finalGenerator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = finalOutput.concat(chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    static from([first, ...runnables]) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    async invoke(input, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            for (const [key, runnable] of Object.entries(this.steps)) {\n                const result = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n                output[key] = result;\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(async (input) => this.func(input), input, options);\n    }\n}\n/**\n * A runnable that passes through the input.\n */\nexport class RunnablePassthrough extends Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    async invoke(input, options) {\n        return this._callWithConfig((input) => Promise.resolve(input), input, options);\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n    }\n    bind(kwargs) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, { ...options, ...this.kwargs });\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? options.map((individualOption) => ({\n                ...individualOption,\n                ...this.kwargs,\n            }))\n            : { ...options, ...this.kwargs };\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, { ...options, ...this.kwargs });\n    }\n}\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, options);\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0\n            ? batchOptions?.maxConcurrency\n            : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const output = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({ steps: runnables });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}